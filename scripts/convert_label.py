import re
import os
import sys
import numpy as np

class ExtentionException(Exception):
    pass

class EmptyLabelException(Exception):
    pass

class Segment:
    """
    a unit of speech (i.e. phoneme, mora)
    """
    def __init__(self, tStart, tEnd, label):
        self.tStart = tStart
        self.tEnd = tEnd
        self.label = label

    def __add__(self, other):
        return Segment(self.tStart, other.tEnd, self.label + other.label)

    def can_follow(self, other):
        """
        return True if Segment self can follow Segment other in one mora,
        otherwise return False
        example: (other, self)
             True: ('s', 'a'), ('sh', 'i'), ('ky', 'o:'), ('t', 's')
             False: ('a', 'q'), ('a', 's'), ('u', 'e'), ('s', 'ha')
        """
        vowels = ['a', 'i', 'u', 'e', 'o', 'a:', 'i:', 'u:', 'e:', 'o:']
        consonants = ['w', 'r', 't', 'y', 'p', 's', 'd', 'f', 'g', 'h', 'j',
                      'k', 'z', 'c', 'b', 'n', 'm']
        only_consonants = lambda x: all([c in consonants for c in x])
        if only_consonants(other.label) and self.label in vowels:
            return True
        if only_consonants(other.label) and only_consonants(self.label):
            return True
        return False

    def to_textgrid_lines(self, segmentIndex):
        label = '' if self.label in ['silB', 'silE'] else self.label
        return [f'        intervals [{segmentIndex}]:',
                f'            xmin = {self.tStart} ',
                f'            xmax = {self.tEnd} ',
                f'            text = "{label}"']

class SegmentationLabel:
    """
    list of segments
    """
    def __init__(self, segments, separatedByMora=False):
        self.segments = segments
        self.separatedByMora = separatedByMora

    def by_moras(self):
        """
        return new SegmentationLabel object whose segment are moras 
        """
        if self.separatedByMora == True:
            return self

        moraSegments = []
        curMoraSegment = None
        for segment in self.segments:
            if curMoraSegment is None:
                curMoraSegment = segment
            elif segment.can_follow(curMoraSegment):
                curMoraSegment += segment
            else:
                moraSegments.append(curMoraSegment)
                curMoraSegment = segment
        if curMoraSegment:
            moraSegments.append(curMoraSegment)
        return SegmentationLabel(moraSegments, separatedByMora=True)

    def _textgrid_headers(self):
        segmentKind = 'mora' if self.separatedByMora else 'phones'
        return ['File type = "ooTextFile"',
                'Object class = "TextGrid"',
                ' ',
                'xmin = 0 ',
               f'xmax = {self.segments[-1].tEnd} ',
                'tiers? <exists> ',
                'size = 1 ',
                'item []: ',
                '    item [1]: ',
                '        class = "IntervalTier" ',
               f'        name = "{segmentKind}" ',
                '        xmin = 0 ',
               f'        xmax = {self.segments[-1].tEnd} ',
               f'        intervals: size = {len(self.segments)} ']

    def to_textgrid(self, textgridFileName):
        """
        save to .TextGrid file, which is available for Praat
        """
        try:
            if not self.segments:
                raise EmptyLabelException(f'warning: no label data found in '
                                          f'{textgridFileName}')
        except EmptyLabelException as e:
            print(e)
            return

        textgridLines = self._textgrid_headers()
        for i, segment in enumerate(self.segments):
            textgridLines.extend(segment.to_textgrid_lines(i + 1))
        with open(textgridFileName, 'w') as f:
            f.write('\n'.join(textgridLines))          

def comma2space(p3):
    if p3 in [" ",""]:
        return "sp"
    return p3
    
def read_lab(filename, element_type='katakana'):
    """
    read label file (.lab) generated by Julius segmentation kit and 
    return SegmentationLabel object
    """
    assert element_type in ['katakana', 'phoneme'], f"element_type must be 'katakana'or'phoneme'."
    try:
        if not re.search(r'\.lab$', filename):
            raise ExtentionException("read_lab supports only .lab")
    except ExtentionException as e:
        print(e)
        return None
    
    chara_len = 0
    with open(filename, 'r') as f:
        labeldata = [line.lower().split(" ") for line in f if line != '']
        segments = []
        if element_type == 'katakana':
            for line in labeldata:
                tStart = float(line[0])
                tEnd = float(line[1])
                label = list(comma2space(line[2].replace("\n","")))
                if "".join(label) == "sil":
                    segments.append(Segment(tStart=tStart, tEnd=tEnd, label="".join(label)))
                elif len(label) == 3:
                    tInter1 = tStart + round((tEnd-tStart)*(1/3),4)
                    tInter2 = tStart + round((tEnd-tStart)*(2/3),4)
                    segments.append(Segment(tStart=tStart, tEnd=tInter1, label=label[0]))
                    segments.append(Segment(tStart=tInter1, tEnd=tInter2, label=label[1]))
                    segments.append(Segment(tStart=tInter2, tEnd=tEnd, label=label[2]))
                    chara_len += 3
                elif len(label) == 2:
                    tInter = tStart + round((tEnd-tStart)*(1/2),4)
                    segments.append(Segment(tStart=tStart, tEnd=tInter, label=label[0]))
                    segments.append(Segment(tStart=tInter, tEnd=tEnd, label=label[1]))
                    chara_len += 2
                else:
                    assert len(label)==1
                    segments.append(Segment(tStart=tStart, tEnd=tEnd, label=label[0]))
                    chara_len += 1
        else: # phoneme
            for line in labeldata:
                tStart = float(line[0])
                tEnd = float(line[1])
                label = list(comma2space(line[2].replace("\n","")))
                if "".join(label) == "sil":
                    segments.append(Segment(tStart=tStart, tEnd=tEnd, label="".join(label)))
                elif len(label) == 3:
                    tInter1 = tStart + round((tEnd-tStart)*(1/3),4)
                    tInter2 = tStart + round((tEnd-tStart)*(2/3),4)
                    segments.append(Segment(tStart=tStart, tEnd=tInter1, label=label[0]))
                    segments.append(Segment(tStart=tInter1, tEnd=tInter2, label=label[1]))
                    segments.append(Segment(tStart=tInter2, tEnd=tEnd, label=label[2]))
                    chara_len += 3
                elif len(label) == 2:
                    tInter = tStart + round((tEnd-tStart)*(1/2),4)
                    segments.append(Segment(tStart=tStart, tEnd=tInter, label=label[0]))
                    segments.append(Segment(tStart=tInter, tEnd=tEnd, label=label[1]))
                    chara_len += 2
                else:
                    assert len(label)==1
                    segments.append(Segment(tStart=tStart, tEnd=tEnd, label=label[0]))
                    chara_len += 1
        return SegmentationLabel(segments), chara_len
